<!DOCTYPE html>
<html>
<head>
    <title>CrispSwCanvas Demo</title>
    <style>
        body {
            margin: 0;
            min-height: 100vh;
            background-color: #fff;
        }
        canvas {
            border: 2px solid #000;
            margin: 10px;
        }
        #targetCanvas, #standardCanvas {
            cursor: crosshair;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .canvas-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: flex-start;
        }
        .canvas-label {
            text-align: center;
            margin-bottom: 5px;
        }
        .background-toggle {
            margin-bottom: 15px;
        }
        .show-transparency {
            /*
            Background pattern a-la photoshop transparency grid pattern
            so we can check where the canvas is being drawn and where it's
            left transparent.
            */
            background-image:
                linear-gradient(45deg, #eee 25%, transparent 25%),
                linear-gradient(-45deg, #eee 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #eee 75%),
                linear-gradient(-45deg, transparent 75%, #eee 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .magnifier-container {
            margin-top: 0;
            text-align: center;
        }
        
        #magnifierCanvas {
            border: 2px solid #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CrispSwCanvas Demo</h1>
        <div class="background-toggle">
            <input type="checkbox" id="showBackground" checked>
            <label for="showBackground">Show background transparency pattern</label>
        </div>
        <div class="canvas-container">
            <div>
                <div class="canvas-label">CrispSwCanvas</div>
                <canvas id="targetCanvas" width="600" height="600"></canvas>
            </div>
            <div>
                <div class="canvas-label">Standard HTML5 Canvas</div>
                <canvas id="standardCanvas" width="600" height="600"></canvas>
            </div>
            <div class="magnifier-container">
                <div class="canvas-label">Pixel Magnifier</div>
                <canvas id="magnifierCanvas" width="400" height="200"></canvas>
            </div>
        </div>
    </div>

    <script src="utils/geometry.js"></script>
    <script src="sw-renderer/SWRendererPixel.js"></script>
    <script src="sw-renderer/SWRendererLine.js"></script>
    <script src="sw-renderer/SWRendererRect.js"></script>

    <script src="crisp-sw-canvas/color-utils.js"></script>
    <script src="crisp-sw-canvas/transform-utils.js"></script>
    <script src="crisp-sw-canvas/ContextState.js"></script>
    <script src="crisp-sw-canvas/CrispSwCanvas.js"></script>
    <script src="crisp-sw-canvas/CrispSwContext.js"></script>
    <script src="crisp-sw-canvas/TransformationMatrix.js"></script>

    <script>
        // Function to run the same drawing commands on both canvases
        function drawScene(ctx) {

            // Basic red rectangle with fill
            // however we are not going to see it
            // because we are going to clear the whole canvas
            // after drawing it
            ctx.fillStyle = "rgb(255, 0, 0)";
            ctx.fillRect(100, 100, 150, 100);
            // clear the whole canvas
            ctx.clearRect(0, 0, 800, 600);

            // test clipping
            ctx.fillStyle = "rgba(255, 0, 0, 0.5)";

            ctx.save()
            ctx.save();
            ctx.rect(50, 50, 100, 100);
            ctx.clip();
            ctx.fillRect(0, 0, 100, 100);
            ctx.restore();
            ctx.translate(20,20);
            ctx.save();
            //ctx.beginPath();
            ctx.rect(50, 50, 100, 100);
            ctx.clip();
            ctx.fillRect(0, 0, 100, 100);
            ctx.restore();

            ctx.translate(140,-20);

            ctx.save();
            ctx.rect(50, 50, 100, 100);
            ctx.clip();
            ctx.fillRect(0, 0, 100, 100);
            ctx.restore();
            ctx.translate(20,20);
            ctx.save();
            ctx.beginPath();
            ctx.rect(50, 50, 100, 100);
            ctx.clip();
            ctx.fillRect(0, 0, 100, 100);
            ctx.restore();

            ctx.translate(140,-20);

            ctx.save();
            ctx.rect(50, 50, 100, 100);
            ctx.clip();
            ctx.fillRect(0, 0, 100, 100);
            ctx.restore();
            ctx.rotate(Math.PI / 16);
            ctx.save();
            //ctx.beginPath();
            ctx.rect(50, 50, 100, 100);
            ctx.clip();
            ctx.fillRect(0, 0, 100, 100);
            ctx.restore();

            ctx.translate(140,-20);

            ctx.save();
            ctx.rect(50, 50, 100, 100);
            ctx.clip();
            ctx.fillRect(0, 0, 100, 100);
            ctx.restore();
            ctx.translate(20,20);
            ctx.save();
            ctx.beginPath();
            ctx.rect(50, 50, 100, 100);
            ctx.clip();
            ctx.fillRect(0, 0, 100, 100);
            ctx.restore();
            ctx.restore();

            // Stroked rectangle with crisp lines
            ctx.strokeStyle = "rgb(0, 0, 255)";
            ctx.lineWidth = 1;
            ctx.strokeRect(20.5, 20.5, 249, 199);

            ctx.rotate(Math.PI / 16);

            // Demonstrate transformations
            ctx.save();
            ctx.translate(150, 150);
            ctx.rotate(Math.PI / 16);
            ctx.scale(2, 2);
            ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
            ctx.fillRect(0, 0, 50, 50);
            ctx.restore();

            // Example of overlapping shapes
            ctx.fillStyle = "rgba(255, 255, 0, 0.5)";
            ctx.fillRect(250, 80, 100, 100);
            
            ctx.fillStyle = "rgba(0, 255, 255, 0.5)";
            ctx.fillRect(300, 130, 100, 100);

            // Example of clearing a region
            ctx.fillStyle = "rgba(128, 0, 128, 1)";
            ctx.fillRect(450, 50, 200, 200);
            ctx.clearRect(500, 100, 100, 100);

            // Example of nested transformations
            ctx.save();
            ctx.translate(350, 350);
            
            ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
            ctx.fillRect(-25, -25, 50, 50);
            
            ctx.rotate(Math.PI / 16);
            ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
            ctx.fillRect(-25, -25, 50, 50);
            
            ctx.scale(1.5, 1.5);
            ctx.fillStyle = "rgba(0, 0, 255, 0.5)";
            ctx.fillRect(-25, -25, 50, 50);
            
            ctx.restore();

            ctx.save();
            ctx.translate(500, 350);
            
            // Draw three overlapping rectangles with different globalAlpha values
            ctx.fillStyle = "rgb(255, 0, 0)";
            ctx.globalAlpha = 1.0;
            ctx.fillRect(-50, -50, 100, 100);
            
            ctx.fillStyle = "rgb(0, 255, 0)";
            ctx.globalAlpha = 0.5;
            ctx.fillRect(-25, -25, 100, 100);
            
            ctx.fillStyle = "rgb(0, 0, 255)";
            ctx.globalAlpha = 0.25;
            ctx.fillRect(0, 0, 100, 100);
            ctx.restore();
        }

        // Create our CrispSwCanvas
        const crispCanvas = new CrispSwCanvas(800, 600);
        const ctx = crispCanvas.getContext('2d');
        drawScene(ctx);

        // Draw the same scene on standard canvas
        const standardCanvas = document.getElementById('standardCanvas');
        const standardCtx = standardCanvas.getContext('2d');
        drawScene(standardCtx);

        // Get the target canvas and blit our content to it
        const targetCanvas = document.getElementById('targetCanvas');
        ctx.blitToCanvas(targetCanvas);

        // Add transparency grid toggle functionality
        const checkbox = document.getElementById('showBackground');
        document.body.classList.add('show-transparency'); // Add class by default
        
        checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                document.body.classList.add('show-transparency');
            } else {
                document.body.classList.remove('show-transparency');
            }
        });

        // Add magnifier functionality
        const magnifierCanvas = document.getElementById('magnifierCanvas');
        const magnifierCtx = magnifierCanvas.getContext('2d');
        const GRID_SIZE = 10;
        const GRID_HEIGHT = 10;
        
        function drawEmptyGrid() {
            // Clear magnifier canvas
            magnifierCtx.clearRect(0, 0, magnifierCanvas.width, magnifierCanvas.height);
            
            const pixelSize = (magnifierCanvas.width / 2) / GRID_SIZE;
            
            // Draw grid for both sides
            [0, magnifierCanvas.width / 2].forEach(offsetX => {
                // Draw grid lines
                magnifierCtx.strokeStyle = 'rgba(128,128,128,0.5)';
                magnifierCtx.lineWidth = 1;
                
                // Vertical lines
                for (let px = 0; px <= GRID_SIZE; px++) {
                    magnifierCtx.beginPath();
                    magnifierCtx.moveTo(offsetX + px * pixelSize, 0);
                    magnifierCtx.lineTo(offsetX + px * pixelSize, GRID_HEIGHT * 2 * pixelSize);
                    magnifierCtx.stroke();
                }
                
                // Horizontal lines
                for (let py = 0; py <= GRID_HEIGHT * 2; py++) {
                    magnifierCtx.beginPath();
                    magnifierCtx.moveTo(offsetX, py * pixelSize);
                    magnifierCtx.lineTo(offsetX + GRID_SIZE * pixelSize, py * pixelSize);
                    magnifierCtx.stroke();
                }
            });
            
            // Draw separator line
            magnifierCtx.strokeStyle = 'rgba(128,128,128,0.8)';
            magnifierCtx.lineWidth = 6;
            magnifierCtx.beginPath();
            magnifierCtx.moveTo(magnifierCanvas.width / 2, 0);
            magnifierCtx.lineTo(magnifierCanvas.width / 2, magnifierCanvas.height);
            magnifierCtx.stroke();
        }
        
        // Draw initial empty grid
        drawEmptyGrid();
        
        function handleCanvasHover(event, sourceCanvas, sourceCtx) {
            const rect = sourceCanvas.getBoundingClientRect();
            const x = Math.floor(event.clientX - rect.left);
            const y = Math.floor(event.clientY - rect.top);
            
            // Get the pixels around the cursor from both canvases
            const halfGrid = Math.floor(GRID_SIZE / 2);
            const crispImageData = targetCanvas.getContext('2d').getImageData(
                Math.max(0, x - halfGrid),
                Math.max(0, y - GRID_HEIGHT / 2),
                GRID_SIZE,
                GRID_HEIGHT * 2
            );
            const standardImageData = standardCtx.getImageData(
                Math.max(0, x - halfGrid),
                Math.max(0, y - GRID_HEIGHT / 2),
                GRID_SIZE,
                GRID_HEIGHT * 2
            );
            
            // Calculate pixel size for magnified view
            const pixelSize = (magnifierCanvas.width / 2) / GRID_SIZE;
            
            // Clear magnifier canvas
            magnifierCtx.clearRect(0, 0, magnifierCanvas.width, magnifierCanvas.height);
            
            // Function to draw grid for each side
            const drawGrid = (imageData, offsetX) => {
                const sourceX = x - halfGrid;
                const sourceY = y - GRID_HEIGHT / 2;
                
                for (let py = 0; py < GRID_HEIGHT * 2; py++) {
                    for (let px = 0; px < GRID_SIZE; px++) {
                        // Calculate actual source coordinates
                        const actualX = sourceX + px;
                        const actualY = sourceY + py;
                        
                        // Check if pixel is within canvas bounds
                        const isOutOfBounds = actualX < 0 || actualY < 0 || 
                                            actualX >= sourceCanvas.width || 
                                            actualY >= sourceCanvas.height;
                        
                        if (isOutOfBounds) {
                            magnifierCtx.fillStyle = 'rgb(128,128,128)';
                        } else {
                            const i = (py * imageData.width + px) * 4;
                            const r = imageData.data[i];
                            const g = imageData.data[i + 1];
                            const b = imageData.data[i + 2];
                            const a = imageData.data[i + 3];
                            magnifierCtx.fillStyle = `rgba(${r},${g},${b},${a/255})`;
                        }
                        
                        // Draw pixel
                        magnifierCtx.fillRect(
                            offsetX + px * pixelSize,
                            py * pixelSize,
                            pixelSize,
                            pixelSize
                        );
                    }
                }
                
                // Draw grid lines after pixels
                magnifierCtx.strokeStyle = 'rgba(128,128,128,0.5)';
                magnifierCtx.lineWidth = 1;
                // Vertical lines
                for (let px = 0; px <= GRID_SIZE; px++) {
                    magnifierCtx.beginPath();
                    magnifierCtx.moveTo(offsetX + px * pixelSize, 0);
                    magnifierCtx.lineTo(offsetX + px * pixelSize, GRID_HEIGHT * 2 * pixelSize);
                    magnifierCtx.stroke();
                }
                // Horizontal lines
                for (let py = 0; py <= GRID_HEIGHT * 2; py++) {
                    magnifierCtx.beginPath();
                    magnifierCtx.moveTo(offsetX, py * pixelSize);
                    magnifierCtx.lineTo(offsetX + GRID_SIZE * pixelSize, py * pixelSize);
                    magnifierCtx.stroke();
                }
                
                // Draw crosshair
                magnifierCtx.strokeStyle = 'red';
                magnifierCtx.lineWidth = 2;
                
                // Vertical line
                magnifierCtx.beginPath();
                magnifierCtx.moveTo(offsetX + halfGrid * pixelSize, 0);
                magnifierCtx.lineTo(offsetX + halfGrid * pixelSize, GRID_HEIGHT * 2 * pixelSize);
                magnifierCtx.stroke();
                
                // Horizontal line
                magnifierCtx.beginPath();
                magnifierCtx.moveTo(offsetX, GRID_HEIGHT * pixelSize / 2);
                magnifierCtx.lineTo(offsetX + GRID_SIZE * pixelSize, GRID_HEIGHT * pixelSize / 2);
                magnifierCtx.stroke();
            };
            
            // Draw left side (CrispSwCanvas)
            drawGrid(crispImageData, 0);
            
            // Draw right side (Standard Canvas)
            drawGrid(standardImageData, magnifierCanvas.width / 2);
            
            // Draw separator line
            magnifierCtx.strokeStyle = 'rgba(128,128,128,0.8)';
            magnifierCtx.lineWidth = 6;
            magnifierCtx.beginPath();
            magnifierCtx.moveTo(magnifierCanvas.width / 2, 0);
            magnifierCtx.lineTo(magnifierCanvas.width / 2, magnifierCanvas.height);
            magnifierCtx.stroke();
            
            // Draw coordinates
            magnifierCtx.font = '14px monospace';
            magnifierCtx.textAlign = 'center';
            magnifierCtx.textBaseline = 'top';
            magnifierCtx.fillStyle = 'black';
            magnifierCtx.fillText(`(${x}, ${y})`, magnifierCanvas.width / 2, 5);
        }
        
        // Add event listeners for both canvases
        const handleMouseMove = (e) => {
            const sourceCanvas = e.target;
            handleCanvasHover(e, sourceCanvas);
        };
        
        targetCanvas.addEventListener('mousemove', handleMouseMove);
        standardCanvas.addEventListener('mousemove', handleMouseMove);
        
        // Clear magnifier when mouse leaves canvases
        targetCanvas.addEventListener('mouseout', () => {
            drawEmptyGrid();
        });
        
        standardCanvas.addEventListener('mouseout', () => {
            drawEmptyGrid();
        });
    </script>
</body>
</html>
